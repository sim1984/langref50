[[fblangref-build-in-packages]]
= Встроенные пакеты

[[fblangref-build-in-package-blob-util-pkg]]
== Пакет `RDB$BLOB_UTIL`

(((RDB$BLOB_UTIL)))
Пакет `RDB$BLOB_UTIL` предназначен для управления BLOB-объектами так, как это не могут сделать стандартные функции Firebird
такие, как `BLOB_APPEND` и `SUBSTRING`, или они работают очень медленно.

Эти подпрограммы работают с двоичными данными напрямую, даже с текстовыми BLOB.

=== Функция `RDB$BLOB_UTIL.NEW_BLOB`

Функция `RDB$BLOB_UTIL.NEW_BLOB` используется для создания нового BLOB. Он возвращает BLOB, подходящий для добавления данных, как это делает `BLOB_APPEND`.

Преимущество по сравнению с `BLOB_APPEND` заключается в том, что можно установить собственные параметры `SEGMENTED` и `TEMP_STORAGE`.

Функция `BLOB_APPEND` всегда создает BLOB во временном хранилище. Это может быть не лучшим подходом,
если созданный BLOB будет храниться в постоянной таблице, поскольку для этого потребуется копирование.

Возвращенный BLOB из этой функции, даже если `TEMP_STORAGE = FALSE`, может использоваться с `BLOB_APPEND` для добавления данных.

.Входные параметры функции `RDB$BLOB_UTIL.NEW_BLOB`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|SEGMENTED
|`BOOLEAN NOT NULL`
|Тип BLOB. Если TRUE - будет создан сегментированный BLOB, FALSE - потоковый.

|TEMP_STORAGE
|`BOOLEAN NOT NULL`
|В каком хранилище создаётся BLOB. TRUE - во временном, FALSE - в постоянном (для записи в обычную таблицу).
|===

.Тип возвращаемого результата
`BLOB SUB_TYPE BINARY`

=== Функция `RDB$BLOB_UTIL.OPEN_BLOB`

Функция `RDB$BLOB_UTIL.OPEN_BLOB` используется для открытия существующего BLOB для чтения.
Она возвращает дескриптор (целое число, связанное с транзакцией), подходящий для использования с другими функциями этого пакета,
такими как `SEEK`, `READ_DATA` и `CLOSE_HANDLE`.

.Входные параметры функции `RDB$BLOB_UTIL.OPEN_BLOB`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|BLOB
|`BLOB NOT NULL`
|Входной BLOB.
|===

.Тип возвращаемого результата
`INTEGER`

=== Функция `RDB$BLOB_UTIL.IS_WRITABLE`

Функция `RDB$BLOB_UTIL.IS_WRITABLE` возвращает `TRUE`, если BLOB подходит для добавления данных без копирования с использованием `BLOB_APPEND`.

.Входные параметры функции `RDB$BLOB_UTIL.IS_WRITABLE`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|BLOB
|`BLOB NOT NULL`
|Проверяемый BLOB.
|===

.Тип возвращаемого результата
`BOOLEAN`

=== Функция `RDB$BLOB_UTIL.READ_DATA`

Функция `RDB$BLOB_UTIL.READ_DATA` используется для чтения фрагментов данных из дескриптора BLOB,
открытого с помощью `RDB$BLOB_UTIL.OPEN_BLOB`. Когда BLOB полностью прочитан и данных больше нет, она возвращает `NULL`.

Если в `LENGTH` передается положительное число, то возвращается `VARBINARY` максимальной длины `LENGTH`.

Если в `LENGTH` передается `NULL`, то возвращается только сегмент BLOB с максимальной длиной 32765.

.Входные параметры функции `RDB$BLOB_UTIL.READ_DATA`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|HANDLE
|`INTEGER NOT NULL`
|Дескриптор открытого BLOB.

|LENGTH
|`INTEGER`
|Количество байт, которое необходимо прочитать.
|===

.Тип возвращаемого результата
`VARBINARY(32765)`

=== Функция `RDB$BLOB_UTIL.SEEK`

Функция `RDB$BLOB_UTIL.SEEK` используется для установки позиции для следующего `READ_DATA`. Она возвращает новую позицию.

Параметр `MODE` может быть 0 (с начала), 1 (с текущей позиции) или 2 (с конца).

Когда параметр `MODE` равен 2, `OFFSET` должен быть нулевым или отрицательным.

.Входные параметры функции `RDB$BLOB_UTIL.SEEK`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|HANDLE
|`INTEGER NOT NULL`
|Дескриптор открытого BLOB.

|MODE
|`INTEGER NOT NULL`
|Режим поиска.

|OFFSET
|`INTEGER NOT NULL`
|Смещение, байт.
|===

.Тип возвращаемого результата
`INTEGER`

=== Процедура `RDB$BLOB_UTIL.CANCEL_BLOB`

Процедура `RDB$BLOB_UTIL.CANCEL_BLOB` используется для немедленного освобождения временного BLOB-объекта, например созданного с помощью `BLOB_APPEND`.

Обратите внимание, что если тот же BLOB используется после отмены, с использованием той же переменной или другой с той же ссылкой на идентификатор BLOB,
то будет вызвана ошибка "invalid blob id error".

.Входные параметры процедуры `RDB$BLOB_UTIL.CANCEL_BLOB`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|BLOB
|`BLOB NOT NULL`
|BLOB для отмены.
|===

=== Процедура `RDB$BLOB_UTIL.CLOSE_HANDLE`

Процедура `RDB$BLOB_UTIL.CLOSE_HANDLE` используется для закрытия дескриптора BLOB, открытого с помощью `RDB$BLOB_UTIL.OPEN_BLOB`.

Незакрытые дескрипторы закрываются автоматически только при завершении транзакции.

.Входные параметры процедуры `RDB$BLOB_UTIL.CLOSE_HANDLE`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|HANDLE
|`INTEGER NOT NULL`
|Дескриптор BLOB для закрытия.
|===

=== Примеры использования `RDB$BLOB_UTIL`

.Создание BLOB во временном пространстве и возврат его в EXECUTE BLOCK
[example]
====
[source,sql]
----
execute block returns (b blob)
as
begin
    -- Create a BLOB handle in the temporary space.
    b = rdb$blob_util.new_blob(false, true);

    -- Add chunks of data.
    b = blob_append(b, '12345');
    b = blob_append(b, '67');

    suspend;
end
----
====

.Открытие BLOB и его возврат по частям в EXECUTE BLOCK
[example]
====
[source,sql]
----
execute block returns (s varchar(10))
as
    declare b blob = '1234567';
    declare bhandle integer;
begin
    -- Open the BLOB and get a BLOB handle.
    bhandle = rdb$blob_util.open_blob(b);

    -- Get chunks of data as string and return.

    s = rdb$blob_util.read_data(bhandle, 3);
    suspend;

    s = rdb$blob_util.read_data(bhandle, 3);
    suspend;

    s = rdb$blob_util.read_data(bhandle, 3);
    suspend;

    -- Here EOF is found, so it returns NULL.
    s = rdb$blob_util.read_data(bhandle, 3);
    suspend;

    -- Close the BLOB handle.
    execute procedure rdb$blob_util.close_handle(bhandle);
end
----
====

.Поиск в BLOB
[example]
====
[source,sql]
----
set term !;

execute block returns (s varchar(10))
as
    declare b blob;
    declare bhandle integer;
begin
    -- Create a stream BLOB handle.
    b = rdb$blob_util.new_blob(false, true);

    -- Add data.
    b = blob_append(b, '0123456789');

    -- Open the BLOB.
    bhandle = rdb$blob_util.open_blob(b);

    -- Seek to 5 since the start.
    rdb$blob_util.seek(bhandle, 0, 5);
    s = rdb$blob_util.read_data(bhandle, 3);
    suspend;

    -- Seek to 2 since the start.
    rdb$blob_util.seek(bhandle, 0, 2);
    s = rdb$blob_util.read_data(bhandle, 3);
    suspend;

    -- Advance 2.
    rdb$blob_util.seek(bhandle, 1, 2);
    s = rdb$blob_util.read_data(bhandle, 3);
    suspend;

    -- Seek to -1 since the end.
    rdb$blob_util.seek(bhandle, 2, -1);
    s = rdb$blob_util.read_data(bhandle, 3);
    suspend;
end!

set term ;!
----
====

.Поверка доступен ли BLOB для записи
[example]
====
[source,sql]
----
create table t(b blob);

set term !;

execute block returns (bool boolean)
as
    declare b blob;
begin
    b = blob_append(null, 'writable');
    bool = rdb$blob_util.is_writable(b);
    suspend;

    insert into t (b) values ('not writable') returning b into b;
    bool = rdb$blob_util.is_writable(b);
    suspend;
end!

set term ;!
----
====


[[fblangref-build-in-package-profiler-pkg]]
== Пакет `RDB$PROFILER`

Пакет `RDB$PROFILER` предназначен для управления сеансами профилирования.

[NOTE]
====
* Пакет `RDB$PROFILER` для управления профилировщиком является стандартным, хотя сам профилировщик
является подключаемым модулем. Используемый профилировщик зависит от настройки `DefaultProfilerPlugin`
в файле `firebird.conf` или `databases.conf` или от параметра `PLUGIN_NAME` в функции `START_SESSION`.
* Firebird 5.0 поставляется с подключаемым модулем профилировщика под названием Default_Profiler.
* Пользователям разрешено профилировать свои собственные подключения. Для профилирования подключений других пользователей требуется системная привилегия `PROFILE_ANY_ATTACHMENT`.
====

Подробнее о профилировании см. в приложении <<fblangref-appx-profiler, Профилирование SQL и PSQL>>.

=== Функция `START_SESSION`

Функция `RDB$PROFILER.START_SESSION` запускает новый сеанс профилировщика, превращает его в текущий сеанс (для заданного `ATTACHMENT_ID`) и возвращает его идентификатор.


.Входные параметры процедуры `RDB$PROFILER.START_SESSION`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|DESCRIPTION
|`VARCHAR(255) CHARACTER SET UTF8`
|Пользовательское описание сеанса профилирования. По умолчанию `NULL`.

|FLUSH_INTERVAL
|`INTEGER`
|Интервал автоматического сброса статистики в таблицы снимков. По умолчанию `NULL`. Измеряется в секундах.

|ATTACHMENT_ID
|`BIGINT`
|Идентификатор соединения для которого запускается сеанс профилирования. По умолчанию `CURRENT_CONNECTION`.

|PLUGIN_NAME
|`VARCHAR(255) CHARACTER SET UTF8`
|Наименование плагина профилирования. По умолчанию `NULL`, что обозначает что будет использоваться плагин профилирования указанный в параметре конфигурации `DefaultProfilerPlugin`.

|PLUGIN_OPTIONS
|`VARCHAR(255) CHARACTER SET UTF8`
|Параметры специфичные для плагина профилирования. По умолчанию `NULL`.
|===


Тип выходного результата: `BIGINT NOT NULL`.

Если параметр `FLUSH_INTERVAL` отличен от `NULL`, то включается автоматический сброс статистики так же, как при вызове `RDB$PROFILER.SET_FLUSH_INTERVAL` вручную.

Если параметр `PLUGIN_NAME` имеет значение `NULL` (по умолчанию), он использует конфигурацию базы данных из параметра `DefaultProfilerPlugin`.

=== Процедура `PAUSE_SESSION`

Процедура `RDB$PROFILER.PAUSE_SESSION` приостанавливает текущий сеанс профилировщика (для заданного `ATTACHMENT_ID`), после чего статистика для последующих выполненных операторов не собирается.

.Входные параметры процедуры `RDB$PROFILER.PAUSE_SESSION`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|FLUSH
|`BOOLEAN`
|Сбрасывать ли текущую статистику профилирования в таблицы моментальных снимков.

|ATTACHMENT_ID
|`BIGINT`
|Идентификатор соединения для которого приостанавливается сеанс профилирования. По умолчанию `CURRENT_CONNECTION`.
|===


Если параметр `FLUSH` имеет значение `TRUE`, таблицы моментальных снимков обновляются данными до текущего момента.
В противном случае данные остаются только в памяти для последующего обновления.

Вызов `RDB$PROFILER.PAUSE_SESSION(TRUE)` имеет тот же смысл, что и вызов `RDB$PROFILER.PAUSE_SESSION(FALSE)`, за которым следует `RDB$PROFILER.FLUSH` (с использованием того же `ATTACHMENT_ID`).


=== Процедура `RESUME_SESSION`

Процедура `RDB$PROFILER.RESUME_SESSION` возобновляет текущий сеанс профилировщика (для заданного `ATTACHMENT_ID`), если он был приостановлен, после чего вновь собирается статистика последующих выполненных операторов.

.Входные параметры процедуры `RDB$PROFILER.RESUME_SESSION`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|ATTACHMENT_ID
|`BIGINT`
|Идентификатор соединения для которого возобновляется сеанс профилирования. По умолчанию `CURRENT_CONNECTION`.
|===


=== Процедура `FINISH_SESSION`

Процедура `RDB$PROFILER.FINISH_SESSION` завершает текущий сеанс профилировщика (для заданного `ATTACHMENT_ID`).

.Входные параметры процедуры `RDB$PROFILER.FINISH_SESSION`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|FLUSH
|`BOOLEAN`
|Сбрасывать ли текущую статистику профилирования в таблицы моментальных снимков.

|ATTACHMENT_ID
|`BIGINT`
|Идентификатор соединения для которого завершается сеанс профилирования. По умолчанию `CURRENT_CONNECTION`.
|===

Если значение параметра `FLUSH` равно `TRUE`, то таблицы моментальных снимков обновляются данными завершенного сеанса (и старых завершенных сеансов, еще не присутствующих в моментальном снимке). В противном случае данные остаются только в памяти для последующего обновления.

Вызов `RDB$PROFILER.FINISH_SESSION(TRUE)` имеет тот же смысл, что и вызов `RDB$PROFILER.FINISH_SESSION(FALSE)`, за которым следует `RDB$PROFILER.FLUSH` (с использованием того же `ATTACHMENT_ID`).

=== Процедура `CANCEL_SESSION`

Процедура `RDB$PROFILER.CANCEL_SESSION` отменяет текущий сеанс профилировщика (для заданного `ATTACHMENT_ID`).

Все данные сеанса, присутствующие в плагине профилировщика, отбрасываются и не сбрасываются.

Уже сброшенные данные не удаляются автоматически.

.Входные параметры процедуры `RDB$PROFILER.CANCEL_SESSION`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|ATTACHMENT_ID
|`BIGINT`
|Идентификатор соединения для которого отменяется сеанс профилирования. По умолчанию `CURRENT_CONNECTION`.
|===


=== Процедура `DISCARD`

Процедура `RDB$PROFILER.DISCARD` удаляет все сеансы (для заданного `ATTACHMENT_ID`) из памяти, не сбрасывая их.

Если есть активная сессия, она отменяется.

.Входные параметры процедуры `RDB$PROFILER.DISCARD`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|ATTACHMENT_ID
|`BIGINT`
|Идентификатор соединения для которого удаляются все сеансы профилирования. По умолчанию `CURRENT_CONNECTION`.
|===


=== Процедура `FLUSH`

Процедура `RDB$PROFILER.FLUSH` обновляет таблицы моментальных снимков данными из сеансов профиля (для заданного `ATTACHMENT_ID`) в памяти.

.Входные параметры процедуры `RDB$PROFILER.FLUSH`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|ATTACHMENT_ID
|`BIGINT`
|Идентификатор соединения для которого обновляются таблицы моментальных снимков из сеансов профилирования. По умолчанию `CURRENT_CONNECTION`.
|===

После обновления данные сохраняются в таблицах `PLG$PROF_SESSIONS`, `PLG$PROF_STATEMENTS`, `PLG$PROF_RECORD_SOURCES`, `PLG$PROF_REQUESTS`, `PLG$PROF_PSQL_STATS` и `PLG$PROF_RECORD_SOURCE_STATS` и могут быть прочитаны и проанализированы пользователем.

Данные обновляются с помощью автономной транзакции, поэтому если процедура вызывается в snapshot транзакции,
данные не будут доступны для прямого чтения в той же транзакции.

После сброса завершенные сеансы удаляются из памяти.


=== Процедура `SET_FLUSH_INTERVAL`

Процедура `RDB$PROFILER.SET_FLUSH_INTERVAL` включает периодическую автоматическую сброс статистики в таблицы моментальных снимков (когда `FLUSH_INTERVAL` больше 0) или выключает (когда `FLUSH_INTERVAL` равно 0).

.Входные параметры процедуры `RDB$PROFILER.SET_FLUSH_INTERVAL`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|FLUSH_INTERVAL
|`INTEGER`
|Интервал автоматического сброса статистики. Задаётся в секундах.

|ATTACHMENT_ID
|`BIGINT`
|Идентификатор соединения для которого обновляются таблицы моментальных снимков из сеансов профилирования. По умолчанию `CURRENT_CONNECTION`.
|===


[[fblangref-build-in-packages-time-zone-util-pkg]]
== Пакет `RDB$TIME_ZONE_UTIL`

(((RDB$TIME_ZONE_UTIL)))
Пакет `RDB$TIME_ZONE_UTIL` содержит процедуры и функции для работы с часовыми поясами.

[[fblangref-build-in-packages-time-zone-util-version]]
=== Функция `RDB$TIME_ZONE_UTIL.DATABASE_VERSION()`

Функция `RDB$TIME_ZONE_UTIL.DATABASE_VERSION` возвращает версию базы данных часовых поясов (из библиотеки icu).

.Тип возвращаемого результата
`VARCHAR(10) CHARACTER SET ASCII`


.Использование функции RDB$TIME_ZONE_UTIL.DATABASE_VERSION
[example]
====
[source,sql]
----
SELECT rdb$time_zone_util.database_version()
FROM rdb$database;
----

[listing]
----
DATABASE_VERSION
================
2021a
----
====

[[fblangref-build-in-packages-timezone-zone-util-transitions]]
=== Процедура `RDB$TIME_ZONE_UTIL.TRANSITIONS()`

Процедура `RDB$TIME_ZONE_UTIL.TRANSITIONS` возвращает набор правил для часового пояса между начальной и конечной временной меткой.


.Входные параметры процедуры `RDB$TIME_ZONE_UTIL.TRANSITIONS`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|RDB$TIME_ZONE_NAME
|`CHAR(63)`
|Наименование часового пояса

|RDB$FROM_TIMESTAMP
|`TIMESTAMP WITH TIME ZONE`
|Начало интервала дат

|RDB$TO_TIMESTAMP
|`TIMESTAMP WITH TIME ZONE`
|Окончание интервала дат
|===

.Выходные параметры процедуры `RDB$TIME_ZONE_UTIL.TRANSITIONS`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|RDB$START_TIMESTAMP
|`TIMESTAMP WITH TIME ZONE`
|Дата начала действия правила

|RDB$END_TIMESTAMP
|`TIMESTAMP WITH TIME ZONE`
|Дата окончания действия правила

|RDB$ZONE_OFFSET
|`SMALLINT`
|Смещение времени в минутах для заданного часового пояса

|RDB$DST_OFFSET
|`SMALLINT`
|Летнее смещение времени в минутах для заданного часового пояса

|RDB$EFFECTIVE_OFFSET
|`SMALLINT`
|Эффективное смещение, вычисляется как `RDB$ZONE_OFFSET + RDB$DST_OFFSET`
|===


.Использование процедуры `RDB$TIME_ZONE_UTIL.TRANSITIONS`
====
[source,sql]
----
SELECT
  RDB$START_TIMESTAMP,
  RDB$END_TIMESTAMP,
  RDB$ZONE_OFFSET AS ZONE_OFF,
  RDB$DST_OFFSET AS DST_OFF,
  RDB$EFFECTIVE_OFFSET AS OFF
FROM rdb$time_zone_util.transitions(
    'America/Sao_Paulo',
    timestamp '2017-01-01',
    timestamp '2019-01-01');
----

[listing]
----
         RDB$START_TIMESTAMP            RDB$END_TIMESTAMP ZONE_OFF DST_OFF  OFF
============================ ============================ ======== ======= ====
2016-10-16 03:00:00.0000 GMT 2017-02-19 01:59:59.9999 GMT     -180      60 -120
2017-02-19 02:00:00.0000 GMT 2017-10-15 02:59:59.9999 GMT     -180       0 -180
2017-10-15 03:00:00.0000 GMT 2018-02-18 01:59:59.9999 GMT     -180      60 -120
2018-02-18 02:00:00.0000 GMT 2018-10-21 02:59:59.9999 GMT     -180       0 -180
2018-10-21 03:00:00.0000 GMT 2019-02-17 01:59:59.9999 GMT     -180      60 -120
----
====
