:sectnums!:
:ditto: &#12291;

[appendix]
[[fblangref-appx-profiler]]
= Профилирование SQL и PSQL

Профилировщик позволяет пользователям измерять стоимость производительности кода SQL и PSQL.

Это реализовано с помощью системного пакета в движке, передающего данные плагину профилировщика.

В этой документации части движка и плагина рассматриваются как единое целое, так как будет использоваться профилировщик по умолчанию (Default_Profiler).

(((RDB$PROFILER)))
Пакет `RDB$PROFILER` позволяет профилировать выполнение кода PSQL, собирая статистику о том, сколько раз выполнялась каждая строка, а также ее минимальное, максимальное и накопленное время выполнения (с точностью до наносекунд), а также открывать и извлекать статистику неявных и явных SQL-курсоров.

[NOTE]
====
К сожалению профилировщик не может работать с базами данных 1 SQL-диалекта.

Это происходит из-за того, что таблицы моментальных снимков содержат поля с типом BIGINT, которые нельзя создать в 1-диалекте.
====

Для сбора данных профиля пользователь должен сначала запустить сеанс профиля с помощью `RDB$PROFILER.START_SESSION`. Эта функция возвращает идентификатор сеанса профиля, который позже сохраняется в таблицах моментальных снимков профилировщика для запроса и анализа пользователем. Сеанс профилировщика может быть локальным (то же соединение) или удаленным (другое соединение).

Удаленное профилирование просто перенаправляет команды на удаленное соединение. Это позволяет клиенту одновременно профилировать несколько сеансов.
Кроме того, локально или удаленно запущенный сеанс профилировщика может получать команды, выданные в другом соединении.

Для удаленных команд требуется, чтобы целевой сеанс находился в состоянии ожидания,
то есть не выполнял других запросов. Когда они не простаивают, вызов блокируется в ожидании этого состояния.

Если удаленное соединение исходит от другого пользователя, вызывающий пользователь должен иметь системную привилегию `PROFILE_ANY_ATTACHMENT`.

После запуска сеанса в памяти начинает собираться статистика PSQL и SQL операторов. Обратите внимание, что сеанс профилировщика собирает данные только об операторах, выполненных только в том соединении, которое связанно с сеансом профилировщика.

Данные агрегируются и сохраняются для каждого запроса. При запросе таблиц моментальных снимков пользователь может выполнять
дополнительную агрегацию по операторам или использовать вспомогательные представления, которые делают это автоматически.

Сеанс профилирования может быть приостановлен для временного отключения сбора статистики. Его можно возобновить позже, чтобы вернуть сбор статистики в том же сеансе.

Новый сеанс профилировщика может быть запущен, когда уже есть активный сеанс. В этом случае текущий сеанс завершается как будто была вызвана процедура
`RDB$PROFILER.FINISH_SESSION(FALSE)`, поэтому таблицы моментальных снимков не обновляются в этот момент.

Чтобы проанализировать собранные данные, пользователь должен сбросить данные в таблицы моментальных снимков,
что можно сделать, завершив или приостановив сеанс (с параметром `FLUSH`, установленным в `TRUE`) или вызвав `RDB$PROFILER.FLUSH`.
Данные сбрасываются с помощью автономной транзакции (транзакция, запущенная и завершенная для конкретной цели обновления данных профилировщика).

Ниже приведен пример сеанса профилировщика и запросов для анализа данных.

[source,sql]
----
-- Preparation - create table and routines that will be analyzed

create table tab (
    id integer not null,
    val integer not null
);

set term !;

create or alter function mult(p1 integer, p2 integer) returns integer
as
begin
    return p1 * p2;
end!

create or alter procedure ins
as
    declare n integer = 1;
begin
    while (n <= 1000)
    do
    begin
        if (mod(n, 2) = 1) then
            insert into tab values (:n, mult(:n, 2));
        n = n + 1;
    end
end!

set term ;!

-- Start profiling

select rdb$profiler.start_session('Profile Session 1') from rdb$database;

set term !;

execute block
as
begin
    execute procedure ins;
    delete from tab;
end!

set term ;!

execute procedure rdb$profiler.finish_session(true);

execute procedure ins;

select rdb$profiler.start_session('Profile Session 2') from rdb$database;

select mod(id, 5),
       sum(val)
  from tab
  where id <= 50
  group by mod(id, 5)
  order by sum(val);

execute procedure rdb$profiler.finish_session(true);

-- Data analysis

set transaction read committed;

select * from plg$prof_sessions;

select * from plg$prof_psql_stats_view;

select * from plg$prof_record_source_stats_view;

select preq.*
  from plg$prof_requests preq
  join plg$prof_sessions pses
    on pses.profile_id = preq.profile_id and
       pses.description = 'Profile Session 1';

select pstat.*
  from plg$prof_psql_stats pstat
  join plg$prof_sessions pses
    on pses.profile_id = pstat.profile_id and
       pses.description = 'Profile Session 1'
  order by pstat.profile_id,
           pstat.request_id,
           pstat.line_num,
           pstat.column_num;

select pstat.*
  from plg$prof_record_source_stats pstat
  join plg$prof_sessions pses
    on pses.profile_id = pstat.profile_id and
       pses.description = 'Profile Session 2'
  order by pstat.profile_id,
           pstat.request_id,
           pstat.cursor_id,
           pstat.record_source_id;
----

[[fblangref-appx-profiler-pkg]]
== Пакет `RDB$PROFILER`

=== Функция `START_SESSION`

Функция `RDB$PROFILER.START_SESSION` запускает новый сеанс профилировщика, превращает его в текущий сеанс (для заданного `ATTACHMENT_ID`) и возвращает его идентификатор.

Если параметр `FLUSH_INTERVAL` отличен от NULL, то включается автоматический сброс статистики так же, как при вызове `RDB$PROFILER.SET_FLUSH_INTERVAL` вручную.

Если параметр `PLUGIN_NAME` имеет значение NULL (по умолчанию), он использует конфигурацию базы данных из параметра `DefaultProfilerPlugin`.

`PLUGIN_OPTIONS` — это параметры, специфичные для плагина, в настоящее время они должны быть равны NULL для плагина `Default_Profiler`.

Входные параметры:

- `DESCRIPTION` type `VARCHAR(255) CHARACTER SET UTF8` default `NULL`
- `FLUSH_INTERVAL` type `INTEGER` default `NULL`
- `ATTACHMENT_ID` type `BIGINT NOT NULL` default `CURRENT_CONNECTION`
- `PLUGIN_NAME` type `VARCHAR(255) CHARACTER SET UTF8` default `NULL`
- `PLUGIN_OPTIONS` type `VARCHAR(255) CHARACTER SET UTF8` default `NULL`

Тип выходного результата: `BIGINT NOT NULL`.

=== Процедура `PAUSE_SESSION`

Процедура `RDB$PROFILER.PAUSE_SESSION` приостанавливает текущий сеанс профилировщика (для заданного `ATTACHMENT_ID`), после чего статистика для последующих выполненных операторов не собирается.

Если параметр `FLUSH` имеет значение `TRUE`, таблицы моментальных снимков обновляются данными до текущего момента.
В противном случае данные остаются только в памяти для последующего обновления.

Вызов `RDB$PROFILER.PAUSE_SESSION(TRUE)` имеет тот же смысл, что и вызов `RDB$PROFILER.PAUSE_SESSION(FALSE)`, за которым следует `RDB$PROFILER.FLUSH` (с использованием того же `ATTACHMENT_ID`).

Входные параметры:

- `FLUSH` type `BOOLEAN NOT NULL` default `FALSE`
- `ATTACHMENT_ID` type `BIGINT NOT NULL` default `CURRENT_CONNECTION`

=== Процедура `RESUME_SESSION`

Процедура `RDB$PROFILER.RESUME_SESSION` возобновляет текущий сеанс профилировщика (для заданного `ATTACHMENT_ID`), если он был приостановлен, после чего вновь собирается статистика последующих выполненных операторов.

Входные параметры:

- `ATTACHMENT_ID` type `BIGINT NOT NULL` default `CURRENT_CONNECTION`

=== Процедура `FINISH_SESSION`

Процедура `RDB$PROFILER.FINISH_SESSION` завершает текущий сеанс профилировщика (для заданного `ATTACHMENT_ID`).

Если значение параметра `FLUSH` равно `TRUE`, то таблицы моментальных снимков обновляются данными завершенного сеанса (и старых завершенных сеансов, еще не присутствующих в моментальном снимке). В противном случае данные остаются только в памяти для последующего обновления.

Вызов `RDB$PROFILER.FINISH_SESSION(TRUE)` имеет тот же смысл, что и вызов `RDB$PROFILER.FINISH_SESSION(FALSE)`, за которым следует `RDB$PROFILER.FLUSH` (с использованием того же `ATTACHMENT_ID`).

Входные параметры:

- `FLUSH` type `BOOLEAN NOT NULL` default `TRUE`
- `ATTACHMENT_ID` type `BIGINT NOT NULL` default `CURRENT_CONNECTION`

=== Процедура `CANCEL_SESSION`

Процедура `RDB$PROFILER.CANCEL_SESSION` отменяет текущий сеанс профилировщика (для заданного `ATTACHMENT_ID`).

Все данные сеанса, присутствующие в плагине профилировщика, отбрасываются и не сбрасываются.

Уже сброшенные данные не удаляются автоматически.

Входные параметры:

- `ATTACHMENT_ID` type `BIGINT NOT NULL` default `CURRENT_CONNECTION`

=== Процедура `DISCARD`

Процедура `RDB$PROFILER.DISCARD` удаляет все сеансы (для заданного `ATTACHMENT_ID`) из памяти, не сбрасывая их.

Если есть активная сессия, она отменяется.

Входные параметры:

- `ATTACHMENT_ID` type `BIGINT NOT NULL` default `CURRENT_CONNECTION`

=== Процедура `FLUSH`

Процедура `RDB$PROFILER.FLUSH` обновляет таблицы моментальных снимков данными из сеансов профиля (для заданного `ATTACHMENT_ID`) в памяти.

После обновления данные сохраняются в таблицах `PLG$PROF_SESSIONS`, `PLG$PROF_STATEMENTS`, `PLG$PROF_RECORD_SOURCES`, `PLG$PROF_REQUESTS`, `PLG$PROF_PSQL_STATS` и `PLG$PROF_RECORD_SOURCE_STATS` и могут быть прочитаны и проанализированы пользователем.

Данные обновляются с помощью автономной транзакции, поэтому если процедура вызывается в snapshot транзакции,
данные не будут доступны для прямого чтения в той же транзакции.

После сброса завершенные сеансы удаляются из памяти.

Входные параметры:

- `ATTACHMENT_ID` type `BIGINT NOT NULL` default `CURRENT_CONNECTION`

=== Процедура `SET_FLUSH_INTERVAL`

Процедура `RDB$PROFILER.SET_FLUSH_INTERVAL` включает периодическую автоматическую очистку (когда `FLUSH_INTERVAL` больше 0) или выключает (когда `FLUSH_INTERVAL` равно 0).

Параметр `FLUSH_INTERVAL` задаётся в секундах.

Входные параметры:

- `FLUSH_INTERVAL` type `INTEGER NOT NULL`
- `ATTACHMENT_ID` type `BIGINT NOT NULL` default `CURRENT_CONNECTION`

== Таблицы моментальных снимков

Таблицы моментальных снимков, а также представления и последовательности, автоматически создаются при первом использовании профилировщика. Они принадлежат текущему пользователю с разрешениями на чтение/запись для `PUBLIC`.

Когда сеанс удаляется, связанные данные в других таблицах моментальных снимков профилировщика также автоматически удаляются с помощью внешних ключей с опцией `DELETE CASCADE`.

Ниже приведен список таблиц, в которых хранятся данные профиля.

=== Таблица `PLG$PROF_SESSIONS`

- `PROFILE_ID` type `BIGINT` - идентификатор сессии профилирования
- `ATTACHMENT_ID` type `BIGINT` - идентификатор соединения для которого производится профилирование
- `USER_NAME` type `CHAR(63) CHARACTER SET UTF8` - имя пользователя
- `DESCRIPTION` type `VARCHAR(255) CHARACTER SET UTF8` - описание переданное в параметре `RDB$PROFILER.START_SESSION`
- `START_TIMESTAMP` type `TIMESTAMP WITH TIME ZONE` - момент начала сессии профилирования
- `FINISH_TIMESTAMP` type `TIMESTAMP WITH TIME ZONE` - момент окончания сессии профилирования (NULL если сессия не завершена)
- Первичный ключ: `PROFILE_ID`

=== Таблица `PLG$PROF_STATEMENTS`

- `PROFILE_ID` type `BIGINT` - идентификатор сессии профилирования
- `STATEMENT_ID` type `BIGINT` - идентификатор оператора
- `PARENT_STATEMENT_ID` type `BIGINT` - родительский идентификатор запроса - относится к подпрограммам.
- `STATEMENT_TYPE` type `VARCHAR(20) CHARACTER SET UTF8` - типа оператора BLOCK, FUNCTION, PROCEDURE или TRIGGER
- `PACKAGE_NAME` type `CHAR(63) CHARACTER SET UTF8` - Имя пакета
- `ROUTINE_NAME` type `CHAR(63) CHARACTER SET UTF8` - Имя функции, процедуры или триггера
- `SQL_TEXT` type `BLOB subtype TEXT CHARACTER SET UTF8` - SQL текст для типа BLOCK
- Первичный ключ: `PROFILE_ID, STATEMENT_ID`

=== Таблица `PLG$PROF_RECORD_SOURCES`

- `PROFILE_ID` type `BIGINT` - идентификатор сессии профилирования
- `STATEMENT_ID` type `BIGINT` - идентификатор оператора
- `CURSOR_ID` type `BIGINT` - идентификатор курсора
- `RECORD_SOURCE_ID` type `BIGINT` - идентификатор источника записи
- `PARENT_RECORD_SOURCE_ID` type `BIGINT` - идентификатор источника родительской записи
- `ACCESS_PATH` type `VARCHAR(255) CHARACTER SET UTF8` - путь доступа к источнику записи
- Первичный ключ: `PROFILE_ID, STATEMENT_ID, CURSOR_ID, RECORD_SOURCE_ID`

=== Таблица `PLG$PROF_REQUESTS`

- `PROFILE_ID` type `BIGINT` - идентификатор сессии профилирования
- `REQUEST_ID` type `BIGINT` - идентификатор запроса
- `STATEMENT_ID` type `BIGINT` - идентификатор оператора
- `CALLER_REQUEST_ID` type `BIGINT` - идентификатор вызывающего запроса
- `START_TIMESTAMP` type `TIMESTAMP WITH TIME ZONE` - момент, когда данный запрос впервые собрал данные профилирования
- `FINISH_TIMESTAMP` type `TIMESTAMP WITH TIME ZONE` - момент завершения запроса
- `TOTAL_ELAPSED_TIME` type `BIGINT` - Накопленное время выполнения запроса (в наносекундах)
- Первичный ключ: `PROFILE_ID, REQUEST_ID`

=== Таблица `PLG$PROF_PSQL_STATS`

- `PROFILE_ID` type `BIGINT` - идентификатор сессии профилирования
- `REQUEST_ID` type `BIGINT` - идентификатор запроса
- `LINE_NUM` type `INTEGER` - номер строки оператора
- `COLUMN_NUM` type `INTEGER` - номер столбца оператора
- `STATEMENT_ID` type `BIGINT` - идентификатор оператора
- `COUNTER` type `BIGINT` - количество выполнений для номера строки/столбца
- `MIN_ELAPSED_TIME` type `BIGINT` - Минимальное время выполнения (в наносекундах) для строки/столбца
- `MAX_ELAPSED_TIME` type `BIGINT` - Максимальное время выполнения (в наносекундах) для строки/столбца
- `TOTAL_ELAPSED_TIME` type `BIGINT` - Накопленное время выполнения (в наносекундах) для строки/столбца
- Первичный ключ: `PROFILE_ID, REQUEST_ID, LINE_NUM, COLUMN_NUM`

=== Таблица `PLG$PROF_RECORD_SOURCE_STATS`

- `PROFILE_ID` type `BIGINT` - идентификатор сессии профилирования
- `REQUEST_ID` type `BIGINT` - идентификатор запроса
- `CURSOR_ID` type `BIGINT` - идентификатор курсора
- `RECORD_SOURCE_ID` type `BIGINT` - идентификатор источника записи
- `STATEMENT_ID` type `BIGINT` - идентификатор оператора
- `OPEN_COUNTER` type `BIGINT` - количество открытий источника записи
- `OPEN_MIN_ELAPSED_TIME` type `BIGINT` - Минимальное время открытия источника записи (в наносекундах)
- `OPEN_MAX_ELAPSED_TIME` type `BIGINT` - Максимальное время открытия источника записи (в наносекундах)
- `OPEN_TOTAL_ELAPSED_TIME` type `BIGINT` - Накопленное время открытия источника записи (в наносекундах)
- `FETCH_COUNTER` type `BIGINT` - Количество извлечений из источника записи
- `FETCH_MIN_ELAPSED_TIME` type `BIGINT` - Минимальное время извлечения записи из источника записи (в наносекундах)
- `FETCH_MAX_ELAPSED_TIME` type `BIGINT` - Максимальное время извлечения записи из источника записи (в наносекундах)
- `FETCH_TOTAL_ELAPSED_TIME` type `BIGINT` - Накопленное время извлечения записей из источника записи (в наносекундах)
- Первичный ключ: `PROFILE_ID, REQUEST_ID, CURSOR_ID, RECORD_SOURCE_ID`

== Вспомогательные представления

Эти представления помогают извлекать данные профилирования, агрегированные на уровне операторов.

Они должны быть предпочтительным способом анализа собранных данных.
Их также можно использовать вместе с таблицами для получения дополнительных данных, отсутствующих в представлениях.

После того как горячие точки найдены, можно детализировать данные на уровне запроса через таблицы.

=== Представление `PLG$PROF_STATEMENT_STATS_VIEW`

[source,sql]
----
select req.profile_id,
       req.statement_id,
       sta.statement_type,
       sta.package_name,
       sta.routine_name,
       sta.parent_statement_id,
       sta_parent.statement_type parent_statement_type,
       sta_parent.routine_name parent_routine_name,
       (select sql_text
          from plg$prof_statements
          where profile_id = req.profile_id and
                statement_id = coalesce(sta.parent_statement_id, req.statement_id)
       ) sql_text,
       count(*) counter,
       min(req.total_elapsed_time) min_elapsed_time,
       max(req.total_elapsed_time) max_elapsed_time,
       cast(sum(req.total_elapsed_time) as bigint) total_elapsed_time,
       cast(sum(req.total_elapsed_time) / count(*) as bigint) avg_elapsed_time
  from plg$prof_requests req
  join plg$prof_statements sta
    on sta.profile_id = req.profile_id and
       sta.statement_id = req.statement_id
  left join plg$prof_statements sta_parent
    on sta_parent.profile_id = sta.profile_id and
       sta_parent.statement_id = sta.parent_statement_id
  group by req.profile_id,
           req.statement_id,
           sta.statement_type,
           sta.package_name,
           sta.routine_name,
           sta.parent_statement_id,
           sta_parent.statement_type,
           sta_parent.routine_name
  order by sum(req.total_elapsed_time) desc
----

=== Представление `PLG$PROF_PSQL_STATS_VIEW`

[source,sql]
----
select pstat.profile_id,
       pstat.statement_id,
       sta.statement_type,
       sta.package_name,
       sta.routine_name,
       sta.parent_statement_id,
       sta_parent.statement_type parent_statement_type,
       sta_parent.routine_name parent_routine_name,
       (select sql_text
          from plg$prof_statements
          where profile_id = pstat.profile_id and
                statement_id = coalesce(sta.parent_statement_id, pstat.statement_id)
       ) sql_text,
       pstat.line_num,
       pstat.column_num,
       cast(sum(pstat.counter) as bigint) counter,
       min(pstat.min_elapsed_time) min_elapsed_time,
       max(pstat.max_elapsed_time) max_elapsed_time,
       cast(sum(pstat.total_elapsed_time) as bigint) total_elapsed_time,
       cast(sum(pstat.total_elapsed_time) / nullif(sum(pstat.counter), 0) as bigint) avg_elapsed_time
  from plg$prof_psql_stats pstat
  join plg$prof_statements sta
    on sta.profile_id = pstat.profile_id and
       sta.statement_id = pstat.statement_id
  left join plg$prof_statements sta_parent
    on sta_parent.profile_id = sta.profile_id and
       sta_parent.statement_id = sta.parent_statement_id
  group by pstat.profile_id,
           pstat.statement_id,
           sta.statement_type,
           sta.package_name,
           sta.routine_name,
           sta.parent_statement_id,
           sta_parent.statement_type,
           sta_parent.routine_name,
           pstat.line_num,
           pstat.column_num
  order by sum(pstat.total_elapsed_time) desc
----

=== Представление `PLG$PROF_RECORD_SOURCE_STATS_VIEW`

[source,sql]
----
select rstat.profile_id,
       rstat.statement_id,
       sta.statement_type,
       sta.package_name,
       sta.routine_name,
       sta.parent_statement_id,
       sta_parent.statement_type parent_statement_type,
       sta_parent.routine_name parent_routine_name,
       (select sql_text
          from plg$prof_statements
          where profile_id = rstat.profile_id and
                statement_id = coalesce(sta.parent_statement_id, rstat.statement_id)
       ) sql_text,
       rstat.cursor_id,
       rstat.record_source_id,
       recsrc.parent_record_source_id,
       recsrc.access_path,
       cast(sum(rstat.open_counter) as bigint) open_counter,
       min(rstat.open_min_elapsed_time) open_min_elapsed_time,
       max(rstat.open_max_elapsed_time) open_max_elapsed_time,
       cast(sum(rstat.open_total_elapsed_time) as bigint) open_total_elapsed_time,
       cast(sum(rstat.open_total_elapsed_time) / nullif(sum(rstat.open_counter), 0) as bigint) open_avg_elapsed_time,
       cast(sum(rstat.fetch_counter) as bigint) fetch_counter,
       min(rstat.fetch_min_elapsed_time) fetch_min_elapsed_time,
       max(rstat.fetch_max_elapsed_time) fetch_max_elapsed_time,
       cast(sum(rstat.fetch_total_elapsed_time) as bigint) fetch_total_elapsed_time,
       cast(sum(rstat.fetch_total_elapsed_time) / nullif(sum(rstat.fetch_counter), 0) as bigint) fetch_avg_elapsed_time,
       cast(coalesce(sum(rstat.open_total_elapsed_time), 0) + coalesce(sum(rstat.fetch_total_elapsed_time), 0) as bigint) open_fetch_total_elapsed_time
  from plg$prof_record_source_stats rstat
  join plg$prof_record_sources recsrc
    on recsrc.profile_id = rstat.profile_id and
       recsrc.statement_id = rstat.statement_id and
       recsrc.cursor_id = rstat.cursor_id and
       recsrc.record_source_id = rstat.record_source_id
  join plg$prof_statements sta
    on sta.profile_id = rstat.profile_id and
       sta.statement_id = rstat.statement_id
  left join plg$prof_statements sta_parent
    on sta_parent.profile_id = sta.profile_id and
       sta_parent.statement_id = sta.parent_statement_id
  group by rstat.profile_id,
           rstat.statement_id,
           sta.statement_type,
           sta.package_name,
           sta.routine_name,
           sta.parent_statement_id,
           sta_parent.statement_type,
           sta_parent.routine_name,
           rstat.cursor_id,
           rstat.record_source_id,
           recsrc.parent_record_source_id,
           recsrc.access_path
  order by coalesce(sum(rstat.open_total_elapsed_time), 0) + coalesce(sum(rstat.fetch_total_elapsed_time), 0) desc
----
